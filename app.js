/**
 * app.js
 * Full RadarNav implementation (road snapping + avg zone averaging + PiP + admin)
 *
 * Requirements (place in same folder):
 * - SCDB_SpeedCams.json
 * - avg_zones.json
 * - assets/chime.mp3
 * - optionally: include NoSleep.js in index.html for wake-lock
 *
 * IMPORTANT: To enable road snap, set ORS_API_KEY below to a valid OpenRouteService API key.
 *
 * This file implements:
 * - Robust SCDB parsing
 * - avg_zones loader
 * - Leaflet map + user marker + orientation
 * - Road snapping via ORS (optional)
 * - Show cameras within 10km and alert 1km ahead (bearing-aware)
 * - Average speed zone tracking (real average speed measured between zone entry/exit)
 * - PiP canvas + toggle (works where supported)
 * - NoSleep integration (if NoSleep.js included)
 * - Admin triple-tap menu with test actions
 *
 * Author: Generated by ChatGPT per user spec
 */

/* ===========================
   CONFIGURATION
   =========================== */
const CONFIG = {
  ORS_API_KEY: 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImE0YzczYmZlMzA5NzRkOTc4OWI4OGU3YTcyNzY4MjdjIiwiaCI6Im11cm11cjY0In0=', // <- PUT YOUR OpenRouteService API KEY HERE to enable road snapping (or leave empty)
  CAMERA_VISIBLE_M: 10000,       // show radars within 10 km
  ALERT_DISTANCE_M: 1000,        // alert when within 1 km
  ALERT_THROTTLE_MS: 5000,      // per-camera throttle
  GLOBAL_ALERT_THROTTLE_MS: 2000,
  GEO_OPTIONS: { enableHighAccuracy: true, maximumAge: 500, timeout: 15000 },
  PIP_FPS: 20,
  PIP_CANVAS_W: 360,
  PIP_CANVAS_H: 200,
  USER_ICON_SIZE: [44, 44],
  AHEAD_ANGLE_DEG: 65,  // camera must be within +/-65 degrees of heading
  MIN_MOVE_TO_REFRESH_MARKERS_M: 25,
  AVG_ZONE_SPEED_WINDOW_S: 2.5, // smoothing window for speed averaging when entering zone
  MAX_VISIBLE_MARKERS: 1200,
  DEBUG: false
};

/* ===========================
   DOM references - should match index.html
   =========================== */
const $ = id => document.getElementById(id);

const DOM = {
  map: $('map'),
  speedValue: $('speed-value'),
  speedUnit: $('speed-unit'),
  alertOverlay: $('alert-overlay'),
  alertText: $('alert-text'),
  avgZoneBar: $('avgZoneBar'),
  progressFill: $('progressFill'),
  zoneLimitVal: $('zoneLimitVal'),
  avgSpeedVal: $('avgSpeedVal'),
  pipToggle: $('toggle-pip'),
  adminPanel: $('admin-panel'),
  reloadBtn: $('reload-btn'),
  clearAlertsBtn: $('clear-alerts'),
  popupContainer: $('popup-container'),
  pipCanvas: $('pipCanvas'),
  pipVideo: $('pipVideo'),
  topBar: $('top-bar')
};

/* Safe DOM fallbacks */
if (!DOM.map) throw new Error('index.html must contain <div id="map"></div>');

/* ===========================
   STATE
   =========================== */
let map = null;
let userMarker = null;
let accuracyCircle = null;
let radars = [];        // array of radar objects {lat, lon, flg, unt, raw}
let avgZones = [];      // array of avg zone objects {start:{lat,lon}, end:{lat,lon}, limit,...}
let visibleMarkers = new Map(); // idx -> Leaflet marker (pool)
let lastPosition = null; // {lat, lon, heading, speedKmh, timestamp}
let lastMarkerRefreshPosition = null;
let watchId = null;
let perCameraLastAlert = new Map();
let lastGlobalAlertTS = 0;
let lastSpeedKmh = 0;
let pipStream = null;
let pipRAF = null;
let pipCtx = null;
let pipEnabled = false;
let noSleep = (window.NoSleep) ? new NoSleep() : null;
let adminTapCount = 0;
let lastAdminTapTS = 0;
let avgZoneActiveState = {
  activeZone: null,
  entryTimestamp: null,
  entrySpeedSamples: [],
  traveledMeters: 0,
  entryPosition: null,
  exitPosition: null
};

/* chime audio */
const chime = new Audio('assets/chime.mp3');

/* ===========================
   UTILITIES
   =========================== */
function dbg(...args){ if (CONFIG.DEBUG) console.log(...args); }
function nowMs(){ return (new Date()).getTime(); }

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

// haversine distance in meters
function distanceMeters(lat1, lon1, lat2, lon2){
  const R = 6371000;
  const toRad = v=>v*Math.PI/180;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// bearing from A to B (degrees 0..360)
function bearing(lat1, lon1, lat2, lon2){
  const toRad = v=>v*Math.PI/180;
  const toDeg = v=>v*180/Math.PI;
  const Ï†1 = toRad(lat1), Ï†2 = toRad(lat2);
  const Î»1 = toRad(lon1), Î»2 = toRad(lon2);
  const y = Math.sin(Î»2-Î»1) * Math.cos(Ï†2);
  const x = Math.cos(Ï†1)*Math.sin(Ï†2) - Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î»2-Î»1);
  return (toDeg(Math.atan2(y,x)) + 360) % 360;
}

function angleDiff(a,b){ let d=Math.abs(a-b)%360; if(d>180) d=360-d; return d; }

function throttle(fn, ms){
  let last=0;
  return (...args)=>{ const t=nowMs(); if(t-last>=ms){ last=t; fn(...args);} };
}

/* small DOM helper for toasts */
function pushToast(text, type='info', ttl=3000){
  if (!DOM.popupContainer) return;
  const el=document.createElement('div');
  el.className=`popup ${type}`;
  el.textContent=text;
  DOM.popupContainer.appendChild(el);
  setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(),400); }, ttl);
}

/* ===========================
   DATA LOADING: SCDB parser & avg_zones loader
   Robust parsing: tries JSON.parse, else splits concatenated objects or line-based
   =========================== */
async function loadSCDB(path='SCDB_SpeedCams.json'){
  try{
    const r = await fetch(path);
    const txt = await r.text();

    // Try direct parse as JSON
    let items = [];
    try{
      const parsed = JSON.parse(txt);
      if(Array.isArray(parsed)) items = parsed;
      else if(parsed && Array.isArray(parsed.cameras)) items = parsed.cameras;
      else if(parsed && Array.isArray(parsed.data)) items = parsed.data;
      else throw new Error('not array - fallback');
    } catch(e){
      // fallback: split into chunks by detecting adjacent objects
      const normalized = txt.replace(/\r\n/g,'\n').replace(/\}\s*\{/g,'}|{').split('|').map(s=>s.trim()).filter(Boolean);
      for(const chunk of normalized){
        try{
          const obj = JSON.parse(chunk);
          items.push(obj);
        } catch(err){
          // try to extract {...}
          const m = chunk.match(/\{[\s\S]*\}/);
          if(m){
            try{ items.push(JSON.parse(m[0])); } catch(e2){ }
          }
        }
      }
    }

    // normalize items
    const normalized = [];
    for(const it of items){
      if(!it) continue;
      const lat = parseFloat(it.lat ?? it.latitude ?? it.LAT ?? it.Lat);
      const lon = parseFloat(it.lon ?? it.lng ?? it.longitude ?? it.LON ?? it.Lon);
      const flg = it.flg != null ? parseInt(it.flg) : (it.type ?? 2);
      const untRaw = it.unt ?? it.unit ?? it['unt '] ?? 'kmh';
      const unt = typeof untRaw === 'string' ? untRaw.trim() : String(untRaw);
      if(Number.isFinite(lat) && Number.isFinite(lon)){
        normalized.push({ lat, lon, flg, unt, raw: it });
      }
    }
    radars = normalized;
    dbg('Loaded radars:', radars.length);
    return radars;
  } catch(err){
    console.error('Failed to load SCDB', err);
    radars = [];
    pushToast('Failed to load SCDB data', 'error', 4000);
    return radars;
  }
}

async function loadAvgZones(path='avg_zones.json'){
  try{
    const r = await fetch(path);
    const parsed = await r.json();
    let arr = [];
    if(Array.isArray(parsed)) arr = parsed;
    else if(parsed && Array.isArray(parsed.zones)) arr = parsed.zones;
    avgZones = arr.map((z, idx)=>{
      // normalize start/end keys flexibly
      const sLat = z.start?.lat ?? z.start?.latitude ?? z.start?.LAT ?? z.start?.Lat;
      const sLon = z.start?.lon ?? z.start?.lng ?? z.start?.longitude ?? z.start?.LON;
      const eLat = z.end?.lat ?? z.end?.latitude ?? z.end?.LAT ?? z.end?.Lat;
      const eLon = z.end?.lon ?? z.end?.lng ?? z.end?.longitude ?? z.end?.LON;
      const limit = z.limit ?? z.speed ?? z.limit_kmh ?? 50;
      return { start: { lat: parseFloat(sLat), lon: parseFloat(sLon) }, end: { lat: parseFloat(eLat), lon: parseFloat(eLon) }, limit, id: z.id ?? `zone_${idx}` };
    }).filter(z => Number.isFinite(z.start.lat) && Number.isFinite(z.start.lon) && Number.isFinite(z.end.lat) && Number.isFinite(z.end.lon));
    dbg('Loaded avgZones', avgZones.length);
    return avgZones;
  }catch(err){
    console.warn('avg_zones not loaded',err);
    avgZones=[];
    return avgZones;
  }
}

/* ===========================
   MAP INIT
   =========================== */
function initMap(){
  map = L.map(DOM.map, { zoomControl: true, attributionControl: false }).setView([39.0, 35.0], 12);

  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap contributors & CARTO',
    maxZoom: 20
  }).addTo(map);

  // create user marker with arrow element
  const userHtml = `<div class="user-icon"><div class="car-arrow" style="transform: rotate(0deg)"></div></div>`;
  const icon = L.divIcon({ className: 'user-icon-wrapper', html: userHtml, iconSize: CONFIG.USER_ICON_SIZE, iconAnchor: [CONFIG.USER_ICON_SIZE[0]/2, CONFIG.USER_ICON_SIZE[1]/2] });
  userMarker = L.marker([39.0, 35.0], { icon, interactive: false }).addTo(map);

  accuracyCircle = L.circle([39.0, 35.0], { radius: 0, color: '#00e5ff', opacity: 0.2, fillOpacity: 0.05 }).addTo(map);

  // create empty groups for radars and avg zones
  map._radarGroup = L.layerGroup().addTo(map);
  map._avgGroup = L.layerGroup().addTo(map);

  // draw avg zones if loaded
  for(const z of avgZones){
    try{
      const poly = L.polyline([[z.start.lat, z.start.lon],[z.end.lat, z.end.lon]], { color:'#6ea8fe', weight:4, opacity:0.45 }).addTo(map._avgGroup);
      z._poly = poly;
    }catch(e){}
  }
}

/* ===========================
   MARKER MANAGEMENT
   - pool markers, show only within 10km
   =========================== */
function refreshMarkers(centerLat, centerLon){
  if(!map || !radars || !radars.length) return;

  const radarGroup = map._radarGroup;
  if(!radarGroup) return;

  // safety cap
  let rendered=0;
  for(let i=0;i<radars.length;i++){
    if(rendered >= CONFIG.MAX_VISIBLE_MARKERS) break;
    const r = radars[i];
    if(!r) continue;
    const d = distanceMeters(centerLat, centerLon, r.lat, r.lon);
    if(d <= CONFIG.CAMERA_VISIBLE_M){
      rendered++;
      if(!visibleMarkers.has(i)){
        const color = r.flg===1 ? '#00c853' : '#ffb300';
        const m = L.circleMarker([r.lat, r.lon], { radius:8, fillColor: color, color:'#111', weight:1, fillOpacity:0.95 }).addTo(radarGroup);
        m.bindPopup(`${r.flg===1?'Average camera':'Fixed camera'}`);
        visibleMarkers.set(i, m);
      } else {
        const m = visibleMarkers.get(i);
        if(!radarGroup.hasLayer(m)) radarGroup.addLayer(m);
      }
    } else {
      if(visibleMarkers.has(i)){
        const m = visibleMarkers.get(i);
        if(radarGroup.hasLayer(m)) radarGroup.removeLayer(m);
      }
    }
  }
  // remove markers that are not in radarGroup to avoid memory growth (keep pool)
  visibleMarkers.forEach((m, idx) => {
    if(!radarGroup.hasLayer(m)) {
      // keep but not in layer
    }
  });
}

/* ===========================
   ROAD SNAPPING using OpenRouteService (optional)
   - nearest endpoint: https://api.openrouteservice.org/v2/nearest/driving-car?api_key=...
   OR Map Matching / Directions for better snapping (NOT implemented here)
   NOTE: ORS nearest returns nearest road point for lat/lon; we will use it when ORS_API_KEY is present
   =========================== */
async function snapToRoad(lat, lon){
  if(!CONFIG.ORS_API_KEY) return { lat, lon, snapped: false };
  try{
    const url = `https://api.openrouteservice.org/v2/nearest/driving-car?api_key=${CONFIG.ORS_API_KEY}&geometry_format=geojson&coords=${lon},${lat}`;
    // Note: ORS nearest expects lon,lat; /nearest/driving-car with coords ...
    // Some ORS endpoints and parameters differ by account; this code aims for a general call.
    const res = await fetch(url);
    if(!res.ok){
      dbg('ORS nearest not OK', res.status);
      return { lat, lon, snapped: false };
    }
    const json = await res.json();
    // parse: json.features[0].geometry.coordinates => [lon,lat]
    if(json && json.features && json.features[0] && json.features[0].geometry && json.features[0].geometry.coordinates){
      const c = json.features[0].geometry.coordinates;
      const snapLon = c[0], snapLat = c[1];
      return { lat: snapLat, lon: snapLon, snapped: true };
    }
    return { lat, lon, snapped: false };
  }catch(err){
    dbg('snap error',err);
    return { lat, lon, snapped: false };
  }
}

/* ===========================
   CAMERA ALERT DETECTION
   - consider only cameras within ALERT_DISTANCE_M
   - bearing-aware: camera must be roughly in front of user heading
   - throttle per camera & global
   =========================== */
function detectCamerasAhead(userLat, userLon, userHeading){
  const now = nowMs();
  if(now - lastGlobalAlertTS < CONFIG.GLOBAL_ALERT_THROTTLE_MS) {
    // still allow scanning (but avoid re-alert spamming)
  }

  for(let i=0;i<radars.length;i++){
    const r = radars[i];
    if(!r) continue;
    const d = distanceMeters(userLat, userLon, r.lat, r.lon);
    if(d > CONFIG.ALERT_DISTANCE_M) continue;

    // check bearing
    const brg = bearing(userLat, userLon, r.lat, r.lon);
    const diff = angleDiff(brg, userHeading || brg);
    if(diff > CONFIG.AHEAD_ANGLE_DEG) continue;

    // per-camera throttle
    const key = `${r.lat},${r.lon}`;
    const lastTs = perCameraLastAlert.get(key) || 0;
    if(now - lastTs < CONFIG.ALERT_THROTTLE_MS) continue;

    // ready to alert
    perCameraLastAlert.set(key, now);
    lastGlobalAlertTS = now;
    triggerCameraAlert(r, d);
    break; // avoid multiple simultaneous alerts
  }
}

function triggerCameraAlert(camera, distanceM){
  const type = camera.flg===1 ? 'Average speed zone' : 'Speed camera';
  showCenteredAlert(`ðŸš¨ ${type} ahead â€” ${Math.round(distanceM)} m`);
  // play chime
  try{ chime.currentTime = 0; chime.play().catch(()=>{}); } catch(e){}

  // if avg zone, try to activate avg zone state
  if(camera.flg === 1){
    const matched = findAvgZoneForCamera(camera);
    if(matched) {
      activeAvgZoneStateEnter(matched.zone);
    } else {
      activeAvgZoneStateEnter({ start:{lat:camera.lat, lon:camera.lon}, end:{lat:camera.lat, lon:camera.lon}, limit:50 }, true);
    }
  }

  // optionally enable PiP automatically (requires user gesture for some browsers) â€” we will only prepare stream
}

/* find an avg zone that is near this camera */
function findAvgZoneForCamera(camera){
  if(!avgZones || !avgZones.length) return null;
  for(const z of avgZones){
    const d1 = distanceMeters(camera.lat, camera.lon, z.start.lat, z.start.lon);
    const d2 = distanceMeters(camera.lat, camera.lon, z.end.lat, z.end.lon);
    if(Math.min(d1,d2) < 200) return { zone: z };
  }
  return null;
}

/* ===========================
   CENTERED ALERT UI
   =========================== */
function showCenteredAlert(text, duration=3500){
  if(DOM.alertText && DOM.alertOverlay){
    DOM.alertText.textContent = text;
    DOM.alertOverlay.classList.remove('hidden');
    DOM.alertOverlay.style.opacity = '1';
    setTimeout(()=>{
      DOM.alertOverlay.style.opacity = '0';
      DOM.alertOverlay.classList.add('hidden');
    }, duration);
  } else {
    pushToast(text, 'info', duration);
  }
}

/* ===========================
   AVERAGE ZONE STATE (entry/exit detection + averaging)
   - track when user enters a zone, record speed samples along the zone,
   - calculate average at exit and compare with zone limit
   =========================== */
function activeAvgZoneStateEnter(zoneObj, synthetic=false){
  avgZoneActiveState.activeZone = zoneObj;
  avgZoneActiveState.entryTimestamp = nowMs();
  avgZoneActiveState.entrySpeedSamples = [];
  avgZoneActiveState.traveledMeters = 0;
  avgZoneActiveState.entryPosition = lastPosition ? { lat: lastPosition.lat, lon: lastPosition.lon } : null;
  avgZoneActiveState.synthetic = !!synthetic;

  // show UI
  const root = document.getElementById('avgZoneBar') || DOM.avgZoneBar;
  if(root) root.classList.remove('hidden');
  if(DOM.zoneLimitVal) DOM.zoneLimitVal.textContent = zoneObj.limit || '';
  if(DOM.avgSpeedVal) DOM.avgSpeedVal.textContent = '0';
  if(DOM.progressFill) DOM.progressFill.style.width = '0%';
}

function activeAvgZoneStateExit(){
  const z = avgZoneActiveState.activeZone;
  if(!z) return;
  // compute average speed from samples
  const samples = avgZoneActiveState.entrySpeedSamples || [];
  const avgKmh = samples.length ? Math.round(samples.reduce((a,b)=>a+b,0)/samples.length) : 0;

  // show final result alert (if we have meaningful data)
  showCenteredAlert(`AVG zone finished â€” avg ${avgKmh} km/h (limit ${z.limit})`, 4500);

  // hide UI
  const root = document.getElementById('avgZoneBar') || DOM.avgZoneBar;
  if(root) root.classList.add('hidden');

  // reset
  avgZoneActiveState.activeZone = null;
  avgZoneActiveState.entryTimestamp = null;
  avgZoneActiveState.entrySpeedSamples = [];
  avgZoneActiveState.entryPosition = null;
  avgZoneActiveState.traveledMeters = 0;
}

/* update avg zone state each GPS tick */
function updateAvgZoneState(lat, lon, kmh){
  const zone = avgZoneActiveState.activeZone;
  if(!zone) return;

  // push speed sample (smoothed)
  avgZoneActiveState.entrySpeedSamples.push(kmh);
  if(avgZoneActiveState.entrySpeedSamples.length > 40) avgZoneActiveState.entrySpeedSamples.shift();

  // progress percent along zone (approx)
  const total = distanceMeters(zone.start.lat, zone.start.lon, zone.end.lat, zone.end.lon);
  const distToStart = distanceMeters(zone.start.lat, zone.start.lon, lat, lon);
  const pct = clamp(distToStart/total, 0, 1);
  if(DOM.progressFill) DOM.progressFill.style.width = `${Math.round(pct*100)}%`;
  if(DOM.avgSpeedVal) DOM.avgSpeedVal.textContent = Math.round(kmh);

  // if at or beyond end => exit
  const isAtEnd = (distToStart >= total - 10) || (distanceMeters(lat, lon, zone.end.lat, zone.end.lon) < 15);
  if(isAtEnd) activeAvgZoneStateExit();
}

/* ===========================
   PiP initialization and render
   - render speed tile or alert card to canvas
   - toggling PiP must be performed by user gesture (we wire it to a button)
   =========================== */
function initPiP(){
  const canvas = DOM.pipCanvas;
  canvas.width = CONFIG.PIP_CANVAS_W;
  canvas.height = CONFIG.PIP_CANVAS_H;
  pipCtx = canvas.getContext('2d');

  // wire toggle button
  if(DOM.pipToggle){
    DOM.pipToggle.addEventListener('click', async ()=>{
      if(!('pictureInPictureEnabled' in document)){
        pushToast('PiP not supported', 'error', 2000);
        return;
      }
      try{
        if(!pipStream){
          pipStream = canvas.captureStream(CONFIG.PIP_FPS);
          DOM.pipVideo.srcObject = pipStream;
          await DOM.pipVideo.play().catch(()=>{});
        }
        if(document.pictureInPictureElement){
          await document.exitPictureInPicture();
          pipEnabled = false;
          DOM.pipToggle.textContent = 'Enable PiP';
        } else {
          await DOM.pipVideo.requestPictureInPicture();
          pipEnabled = true;
          DOM.pipToggle.textContent = 'Disable PiP';
        }
      }catch(err){
        console.error('PiP error', err);
        pushToast('PiP error', 'error', 2000);
      }
    });
  }

  // Start RAF loop to keep canvas updated
  function loop(){
    renderPipFrame(lastSpeedKmh);
    pipRAF = requestAnimationFrame(loop);
  }
  if(!pipRAF) loop();
}

function renderPipFrame(kmh=0){
  const canvas = DOM.pipCanvas;
  const ctx = pipCtx;
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#071021';
  ctx.fillRect(0,0,w,h);

  // if alert showing (alert overlay not hidden), show alert card
  const overlay = DOM.alertOverlay;
  const alertVisible = overlay && !overlay.classList.contains('hidden') && overlay.style.opacity !== '0';

  if(alertVisible){
    roundRect(ctx, 12, 12, w-24, h-24, 14, '#122033');
    ctx.font = '20px Inter, Arial';
    ctx.fillStyle = '#ffd7d7';
    ctx.fillText('ðŸš¨', 28, 48);
    ctx.font = '14px Inter, Arial';
    ctx.fillStyle = '#fff';
    const text = DOM.alertText ? DOM.alertText.textContent : 'Alert';
    wrapText(ctx, text, 70, 40, w-100, 18);
  } else {
    // speed tile
    roundRect(ctx, 20, 40, w-40, h-80, 12, '#0b2a33');
    ctx.font = '30px Inter, Arial';
    ctx.fillStyle = '#00e5ff';
    ctx.fillText(`${kmh} km/h`, 40, 100);
    if(avgZoneActiveState.activeZone){
      ctx.font = '12px Inter, Arial';
      ctx.fillStyle = '#fff';
      ctx.fillText(`AVG ZONE ${avgZoneActiveState.activeZone.limit || ''}`, 40, 130);
    }
  }
}

/* canvas helpers */
function roundRect(ctx,x,y,w,h,r,fillStyle){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+w-r,y);
  ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r);
  ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h);
  ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
  ctx.fillStyle = fillStyle;
  ctx.fill();
}

function wrapText(ctx,text,x,y,maxWidth,lineHeight){
  const words = text.split(' ');
  let line = '';
  for(let n=0;n<words.length;n++){
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    if(testWidth > maxWidth && n>0){
      ctx.fillText(line, x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, y);
}

/* ===========================
   GPS monitoring
   - watchPosition
   - optionally snap to road via ORS
   - call update functions (markers, detection, avg zone, pip)
   =========================== */
function startGPS(){
  if(!navigator.geolocation) {
    pushToast('Geolocation not available', 'error', 4000);
    return;
  }
  watchId = navigator.geolocation.watchPosition(async (pos)=>{
    try{
      let lat = pos.coords.latitude;
      let lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;
      const gpsSpeed = pos.coords.speed; // m/s or null
      // compute km/h (if null, keep last)
      const kmh = (typeof gpsSpeed === 'number' && !isNaN(gpsSpeed)) ? Math.round(gpsSpeed*3.6) : lastSpeedKmh;

      lastSpeedKmh = kmh;

      // attempt road snapping if ORS available
      let snapped = { lat, lon, snapped: false };
      try{
        if(CONFIG.ORS_API_KEY){
          // throttle calls: only snap if moved > ~10 meters since last snap OR first time
          if(!lastPosition || distanceMeters(lastPosition.lat, lastPosition.lon, lat, lon) > 10){
            // try ORS nearest endpoint
            snapped = await snapNearestORS(lat, lon);
            // ORS may fail, fallback to raw lat/lon
          }
        }
      }catch(e){
        dbg('snap error', e);
        snapped = { lat, lon, snapped:false };
      }

      // determine heading - prefer device heading if present, else compute bearing from last position
      let heading = pos.coords.heading;
      if(heading == null && lastPosition){
        heading = bearing(lastPosition.lat, lastPosition.lon, snapped.lat, snapped.lon);
      }
      // update lastPosition
      const newPos = { lat: snapped.lat, lon: snapped.lon, heading, speed: kmh, accuracy: acc, timestamp: nowMs() };
      // calculate movement distance for marker refresh threshold
      const moved = !lastPosition ? Number.POSITIVE_INFINITY : distanceMeters(lastPosition.lat, lastPosition.lon, newPos.lat, newPos.lon);

      lastPosition = newPos;

      // update UI: speed
      updateSpeedUI(kmh);

      // update marker and accuracy circle
      updateUserMarker(newPos.lat, newPos.lon, newPos.heading, newPos.accuracy);

      // refresh markers if moved > threshold or first time
      if(!lastMarkerRefreshPosition || moved >= CONFIG.MIN_MOVE_TO_REFRESH_MARKERS_M){
        refreshMarkers(newPos.lat, newPos.lon);
        lastMarkerRefreshPosition = { lat: newPos.lat, lon: newPos.lon };
      }

      // detect cameras ahead (bearing-aware)
      detectCamerasAhead(newPos.lat, newPos.lon, newPos.heading);

      // detect avg zone progress
      detectAvgZoneForPosition(newPos.lat, newPos.lon, kmh);

      // render PiP
      renderPipFrame(kmh);

    } catch(err){
      console.error('GPS loop error', err);
    }
  }, (err)=>{
    console.warn('GPS error', err);
    pushToast('GPS error: ' + (err.message || err.code), 'error', 3000);
  }, CONFIG.GEO_OPTIONS);
}

/* ORS nearest endpoint helper - returns {lat, lon, snapped} */
async function snapNearestORS(lat, lon){
  try{
    const url = `https://api.openrouteservice.org/v2/nearest/driving-car?api_key=${encodeURIComponent(CONFIG.ORS_API_KEY)}&geometry_format=geojson&coords=${lon},${lat}`;
    const res = await fetch(url);
    if(!res.ok) { dbg('ORS HTTP not OK', res.status); return { lat, lon, snapped:false }; }
    const json = await res.json();
    if(json && json.features && json.features[0] && json.features[0].geometry && json.features[0].geometry.coordinates){
      const coords = json.features[0].geometry.coordinates;
      const snappedLon = coords[0], snappedLat = coords[1];
      return { lat: snappedLat, lon: snappedLon, snapped: true };
    }
    return { lat, lon, snapped:false };
  }catch(e){
    dbg('ORS error', e);
    return { lat, lon, snapped:false };
  }
}

/* ===========================
   Avg zone detection using current position
   We determine if user projects onto any avg zone segment; if inside, update state
   =========================== */
function detectAvgZoneForPosition(lat, lon, kmh){
  // find zone where pos projects between start and end
  let found = null;
  for(const z of avgZones){
    const total = distanceMeters(z.start.lat, z.start.lon, z.end.lat, z.end.lon);
    const dStart = distanceMeters(z.start.lat, z.start.lon, lat, lon);
    const dEnd = distanceMeters(z.end.lat, z.end.lon, lat, lon);
    const gap = Math.abs((dStart + dEnd) - total);
    if(gap < 60 && dStart <= total + 30){
      const pct = clamp(dStart/total, 0, 1);
      found = { zone: z, pct, total, dStart, dEnd };
      break;
    }
  }

  if(found){
    // if not active yet, enter
    if(!avgZoneActiveState.activeZone || avgZoneActiveState.activeZone.id !== found.zone.id){
      activeAvgZoneStateEnter(found.zone, false);
    }
    // update progress & push speed sample
    if(avgZoneActiveState.activeZone){
      // smooth sample push
      avgZoneActiveState.entrySpeedSamples.push(kmh);
      if(avgZoneActiveState.entrySpeedSamples.length > 40) avgZoneActiveState.entrySpeedSamples.shift();
      const samples = avgZoneActiveState.entrySpeedSamples;
      const avg = samples.length ? Math.round(samples.reduce((a,b)=>a+b,0)/samples.length) : kmh;
      // update UI
      if(DOM.progressFill) DOM.progressFill.style.width = `${Math.round(found.pct*100)}%`;
      if(DOM.avgSpeedVal) DOM.avgSpeedVal.textContent = `${avg}`;
      if(DOM.zoneLimitVal) DOM.zoneLimitVal.textContent = `${found.zone.limit}`;
    }
  } else {
    // not in any zone
    activeAvgZoneStateExit();
  }
}

/* ===========================
   UI: speed, marker update, toasts
   =========================== */
function updateSpeedUI(kmh){
  if(DOM.speedValue) DOM.speedValue.textContent = `${kmh}`;
  // color logic could be added to change background on overspeed, etc.
}

function updateUserMarker(lat, lon, heading, accuracy){
  if(!userMarker) return;
  userMarker.setLatLng([lat, lon]);
  const el = userMarker.getElement();
  if(el){
    const arrow = el.querySelector('.car-arrow');
    if(arrow) arrow.style.transform = `rotate(${heading ?? 0}deg)`;
  }
  if(accuracyCircle){
    accuracyCircle.setLatLng([lat, lon]);
    if(typeof accuracy === 'number' && !isNaN(accuracy)){
      accuracyCircle.setRadius(accuracy);
    }
  }
}

/* ===========================
   Admin (triple tap) + controls
   =========================== */
function initAdmin(){
  document.body.addEventListener('touchend', (e)=>{
    const t = nowMs();
    if(t - lastAdminTapTS < 600) adminTapCount++;
    else adminTapCount = 1;
    lastAdminTapTS = t;
    if(adminTapCount >= 3){
      adminTapCount = 0;
      const panel = DOM.adminPanel || document.getElementById('admin-panel');
      if(panel) panel.classList.toggle('collapsed');
      pushToast('Admin toggled', 'info', 1200);
    }
  });

  if(DOM.reloadBtn){
    DOM.reloadBtn.addEventListener('click', async ()=>{
      pushToast('Reloading data...', 'info', 900);
      await loadSCDB();
      await loadAvgZones();
      if(lastPosition) refreshMarkers(lastPosition.lat, lastPosition.lon);
      pushToast('Reloaded', 'success', 900);
    });
  }
  if(DOM.clearAlertsBtn){
    DOM.clearAlertsBtn.addEventListener('click', ()=>{
      (DOM.alertOverlay || document.getElementById('alert-overlay'))?.classList.add('hidden');
      pushToast('Alerts cleared', 'success', 900);
    });
  }
}

/* ===========================
   NO SLEEP initialization (first gesture)
   =========================== */
function initNoSleep(){
  if(window.NoSleep){
    const n = new NoSleep();
    const enableOnce = ()=>{ try{ n.enable(); }catch(e){}; document.removeEventListener('touchstart', enableOnce); document.removeEventListener('click', enableOnce); };
    document.addEventListener('touchstart', enableOnce, { once: true });
    document.addEventListener('click', enableOnce, { once: true });
  }
}

/* ===========================
   BOOT
   =========================== */
async function boot(){
  try{
    // load data
    await loadSCDB();
    await loadAvgZones();

    // init map
    initMap();

    // init pip
    initPiP();

    // admin interactions
    initAdmin();

    // no-sleep hook
    initNoSleep();

    // start GPS
    startGPS();

    pushToast('RadarNav ready', 'success', 1200);
  } catch(err){
    console.error('boot error', err);
    pushToast('Initialization error: ' + (err.message||err), 'error', 4000);
  }
}

/* start on load */
window.addEventListener('load', boot);